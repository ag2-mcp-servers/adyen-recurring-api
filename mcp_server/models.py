# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T09:07:57+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional

from pydantic import BaseModel, Field, constr


class Address(BaseModel):
    city: constr(max_length=3000) = Field(
        ..., description='The name of the city. Maximum length: 3000 characters.'
    )
    country: str = Field(
        ...,
        description="The two-character ISO-3166-1 alpha-2 country code. For example, **US**.\n> If you don't know the country or are not collecting the country from the shopper, provide `country` as `ZZ`.",
    )
    houseNumberOrName: constr(max_length=3000) = Field(
        ...,
        description='The number or name of the house. Maximum length: 3000 characters.',
    )
    postalCode: str = Field(
        ...,
        description='A maximum of five digits for an address in the US, or a maximum of ten characters for an address in all other countries.',
    )
    stateOrProvince: Optional[str] = Field(
        None,
        description='The two-character ISO 3166-2 state or province code. For example, **CA** in the US or **ON** in Canada.\n> Required for the US and Canada.',
    )
    street: constr(max_length=3000) = Field(
        ...,
        description='The name of the street. Maximum length: 3000 characters.\n> The house number should not be included in this field; it should be separately provided via `houseNumberOrName`.',
    )


class Amount(BaseModel):
    currency: constr(min_length=3, max_length=3) = Field(
        ...,
        description='The three-character [ISO currency code](https://docs.adyen.com/development-resources/currency-codes).',
    )
    value: int = Field(
        ...,
        description='The amount of the transaction, in [minor units](https://docs.adyen.com/development-resources/currency-codes).',
    )


class BankAccount(BaseModel):
    bankAccountNumber: Optional[str] = Field(
        None, description='The bank account number (without separators).'
    )
    bankCity: Optional[str] = Field(None, description='The bank city.')
    bankLocationId: Optional[str] = Field(
        None,
        description='The location id of the bank. The field value is `nil` in most cases.',
    )
    bankName: Optional[str] = Field(None, description='The name of the bank.')
    bic: Optional[str] = Field(
        None,
        description='The [Business Identifier Code](https://en.wikipedia.org/wiki/ISO_9362) (BIC) is the SWIFT address assigned to a bank. The field value is `nil` in most cases.',
    )
    countryCode: Optional[str] = Field(
        None,
        description="Country code where the bank is located.\n\nA valid value is an ISO two-character country code (e.g. 'NL').",
    )
    iban: Optional[str] = Field(
        None,
        description='The [International Bank Account Number](https://en.wikipedia.org/wiki/International_Bank_Account_Number) (IBAN).',
    )
    ownerName: Optional[str] = Field(
        None,
        description="The name of the bank account holder.\nIf you submit a name with non-Latin characters, we automatically replace some of them with corresponding Latin characters to meet the FATF recommendations. For example:\n* χ12 is converted to ch12.\n* üA is converted to euA.\n* Peter Møller is converted to Peter Mller, because banks don't accept 'ø'.\nAfter replacement, the ownerName must have at least three alphanumeric characters (A-Z, a-z, 0-9), and at least one of them must be a valid Latin character (A-Z, a-z). For example:\n* John17 - allowed.\n* J17 - allowed.\n* 171 - not allowed.\n* John-7 - allowed.\n> If provided details don't match the required format, the response returns the error message: 203 'Invalid bank account holder name'.",
    )
    taxId: Optional[str] = Field(None, description="The bank account holder's tax ID.")


class Card(BaseModel):
    cvc: Optional[constr(min_length=1, max_length=20)] = Field(
        None,
        description='The [card verification code](https://docs.adyen.com/payments-fundamentals/payment-glossary#card-security-code-cvc-cvv-cid) (1-20 characters). Depending on the card brand, it is known also as:\n* CVV2/CVC2 – length: 3 digits\n* CID – length: 4 digits\n> If you are using [Client-Side Encryption](https://docs.adyen.com/classic-integration/cse-integration-ecommerce), the CVC code is present in the encrypted data. You must never post the card details to the server.\n> This field must be always present in a [one-click payment request](https://docs.adyen.com/classic-integration/recurring-payments).\n> When this value is returned in a response, it is always empty because it is not stored.',
    )
    expiryMonth: Optional[constr(min_length=1, max_length=2)] = Field(
        None,
        description='The card expiry month.\nFormat: 2 digits, zero-padded for single digits. For example:\n* 03 = March\n* 11 = November',
    )
    expiryYear: Optional[constr(min_length=4, max_length=4)] = Field(
        None, description='The card expiry year.\nFormat: 4 digits. For example: 2020'
    )
    holderName: Optional[constr(min_length=1, max_length=50)] = Field(
        None, description='The name of the cardholder, as printed on the card.'
    )
    issueNumber: Optional[constr(min_length=1, max_length=2)] = Field(
        None, description='The issue number of the card (for some UK debit cards only).'
    )
    number: Optional[constr(min_length=4, max_length=19)] = Field(
        None,
        description='The card number (4-19 characters). Do not use any separators.\nWhen this value is returned in a response, only the last 4 digits of the card number are returned.',
    )
    startMonth: Optional[constr(min_length=1, max_length=2)] = Field(
        None,
        description='The month component of the start date (for some UK debit cards only).',
    )
    startYear: Optional[constr(min_length=4, max_length=4)] = Field(
        None,
        description='The year component of the start date (for some UK debit cards only).',
    )


class DisablePermitRequest(BaseModel):
    merchantAccount: str = Field(
        ...,
        description='The merchant account identifier, with which you want to process the transaction.',
    )
    token: str = Field(..., description='The permit token to disable.')


class DisablePermitResult(BaseModel):
    pspReference: Optional[str] = Field(
        None,
        description='A unique reference associated with the request. This value is globally unique; quote it when communicating with us about this request.',
    )
    status: Optional[str] = Field(None, description='Status of the disable request.')


class DisableRequest(BaseModel):
    contract: Optional[str] = Field(
        None,
        description='Specify the contract if you only want to disable a specific use.\n\nThis field can be set to one of the following values, or to their combination (comma-separated):\n* ONECLICK\n* RECURRING\n* PAYOUT',
    )
    merchantAccount: str = Field(
        ...,
        description='The merchant account identifier with which you want to process the transaction.',
    )
    recurringDetailReference: Optional[str] = Field(
        None,
        description='The ID that uniquely identifies the recurring detail reference.\n\nIf it is not provided, the whole recurring contract of the `shopperReference` will be disabled, which includes all recurring details.',
    )
    shopperReference: str = Field(
        ...,
        description='The ID that uniquely identifies the shopper.\n\nThis `shopperReference` must be the same as the `shopperReference` used in the initial payment.',
    )


class DisableResult(BaseModel):
    response: Optional[str] = Field(
        None,
        description='Depending on whether a specific recurring detail was in the request, result is either [detail-successfully-disabled] or [all-details-successfully-disabled].',
    )


class Name(BaseModel):
    firstName: str = Field(..., description='The first name.')
    lastName: str = Field(..., description='The last name.')


class NotifyShopperRequest(BaseModel):
    amount: Amount = Field(..., description='The amount of the upcoming payment.')
    billingDate: Optional[str] = Field(
        None,
        description='Date on which the subscription amount will be debited from the shopper. In YYYY-MM-DD format',
    )
    billingSequenceNumber: Optional[str] = Field(
        None,
        description='Sequence of the debit. Depends on Frequency and Billing Attempts Rule.',
    )
    displayedReference: Optional[str] = Field(
        None,
        description='Reference of Pre-debit notification that is displayed to the shopper. Optional field. Maps to reference if missing',
    )
    merchantAccount: str = Field(
        ...,
        description='The merchant account identifier with which you want to process the transaction.',
    )
    recurringDetailReference: Optional[str] = Field(
        None,
        description='This is the `recurringDetailReference` returned in the response when you created the token.',
    )
    reference: str = Field(
        ...,
        description='Pre-debit notification reference sent by the merchant. This is a mandatory field',
    )
    shopperReference: str = Field(
        ...,
        description='The ID that uniquely identifies the shopper.\n\nThis `shopperReference` must be the same as the `shopperReference` used in the initial payment.',
    )
    storedPaymentMethodId: Optional[str] = Field(
        None,
        description='This is the `recurringDetailReference` returned in the response when you created the token.',
    )


class NotifyShopperResult(BaseModel):
    displayedReference: Optional[str] = Field(
        None,
        description='Reference of Pre-debit notification that is displayed to the shopper',
    )
    message: Optional[str] = Field(
        None, description='A simple description of the `resultCode`.'
    )
    pspReference: Optional[str] = Field(
        None, description='The unique reference that is associated with the request.'
    )
    reference: Optional[str] = Field(
        None, description='Reference of Pre-debit notification sent in my the merchant'
    )
    resultCode: Optional[str] = Field(
        None, description='The code indicating the status of notification.'
    )
    shopperNotificationReference: Optional[str] = Field(
        None, description='The unique reference for the request sent downstream.'
    )
    storedPaymentMethodId: Optional[str] = Field(
        None,
        description='This is the recurringDetailReference returned in the response when token was created',
    )


class PermitRestriction(BaseModel):
    maxAmount: Optional[Amount] = Field(
        None,
        description='The total sum amount of one or more payments made using this permit may not exceed this amount if set.',
    )
    singleTransactionLimit: Optional[Amount] = Field(
        None,
        description='The amount of any single payment using this permit may not exceed this amount if set.',
    )
    singleUse: Optional[bool] = Field(
        None,
        description='Only a single payment can be made using this permit if set to true, otherwise multiple payments are allowed.',
    )


class PermitResult(BaseModel):
    resultKey: Optional[str] = Field(
        None, description='The key to link permit requests to permit results.'
    )
    token: Optional[str] = Field(
        None,
        description='The permit token which is used to make payments by the partner company.',
    )


class Contract(Enum):
    ONECLICK = 'ONECLICK'
    RECURRING = 'RECURRING'
    PAYOUT = 'PAYOUT'


class TokenService(Enum):
    VISATOKENSERVICE = 'VISATOKENSERVICE'
    MCTOKENSERVICE = 'MCTOKENSERVICE'


class Recurring(BaseModel):
    contract: Optional[Contract] = Field(
        None,
        description='The type of recurring contract to be used.\nPossible values:\n* `ONECLICK` – Payment details can be used to initiate a one-click payment, where the shopper enters the [card security code (CVC/CVV)](https://docs.adyen.com/payments-fundamentals/payment-glossary#card-security-code-cvc-cvv-cid).\n* `RECURRING` – Payment details can be used without the card security code to initiate [card-not-present transactions](https://docs.adyen.com/payments-fundamentals/payment-glossary#card-not-present-cnp).\n* `ONECLICK,RECURRING` – Payment details can be used regardless of whether the shopper is on your site or not.\n* `PAYOUT` – Payment details can be used to [make a payout](https://docs.adyen.com/online-payments/online-payouts).',
    )
    recurringDetailName: Optional[str] = Field(
        None, description='A descriptive name for this detail.'
    )
    recurringExpiry: Optional[datetime] = Field(
        None,
        description='Date after which no further authorisations shall be performed. Only for 3D Secure 2.',
    )
    recurringFrequency: Optional[str] = Field(
        None,
        description='Minimum number of days between authorisations. Only for 3D Secure 2.',
    )
    tokenService: Optional[TokenService] = Field(
        None, description='The name of the token service.'
    )


class RecurringDetailsRequest(BaseModel):
    merchantAccount: str = Field(
        ...,
        description='The merchant account identifier you want to process the (transaction) request with.',
    )
    recurring: Optional[Recurring] = Field(
        None,
        description="A container for the type of a recurring contract to be retrieved.\n\nThe contract value needs to match the contract value submitted in the payment transaction used to create a recurring contract.\nHowever, if `ONECLICK,RECURRING` is the original contract definition in the initial payment, then `contract` should take either `ONECLICK` or `RECURRING`, depending on whether or not you want the shopper to enter their card's security code when they finalize their purchase.",
    )
    shopperReference: str = Field(
        ...,
        description='The reference you use to uniquely identify the shopper (e.g. user ID or account ID).',
    )


class ScheduleAccountUpdaterRequest(BaseModel):
    additionalData: Optional[Dict[str, str]] = Field(
        None,
        description='This field contains additional data, which may be required for a particular request.',
    )
    card: Optional[Card] = Field(
        None,
        description='Credit card data.\n\nOptional if `shopperReference` and `selectedRecurringDetailReference` are provided.',
    )
    merchantAccount: str = Field(..., description='Account of the merchant.')
    reference: str = Field(
        ..., description='A reference that merchants can apply for the call.'
    )
    selectedRecurringDetailReference: Optional[str] = Field(
        None,
        description='The selected detail recurring reference.\n\nOptional if `card` is provided.',
    )
    shopperReference: Optional[str] = Field(
        None,
        description='The reference of the shopper that owns the recurring contract.\n\nOptional if `card` is provided.',
    )


class ScheduleAccountUpdaterResult(BaseModel):
    pspReference: str = Field(
        ...,
        description="Adyen's 16-character unique reference associated with the transaction. This value is globally unique; quote it when communicating with us about this request.",
    )
    result: str = Field(
        ...,
        description='The result of scheduling an Account Updater. If scheduling was successful, this field returns **Success**; otherwise it contains the error message.',
    )


class ServiceError(BaseModel):
    additionalData: Optional[Dict[str, str]] = Field(
        None,
        description='Contains additional information about the payment. Some data fields are included only if you select them first. Go to **Customer Area** > **Developers** > **Additional data**.',
    )
    errorCode: Optional[str] = Field(
        None, description='The error code mapped to the error message.'
    )
    errorType: Optional[str] = Field(None, description='The category of the error.')
    message: Optional[str] = Field(
        None, description='A short explanation of the issue.'
    )
    pspReference: Optional[str] = Field(
        None, description='The PSP reference of the payment.'
    )
    status: Optional[int] = Field(None, description='The HTTP response status.')


class TokenDetails(BaseModel):
    tokenData: Optional[Dict[str, str]] = None
    tokenDataType: Optional[str] = None


class CreatePermitResult(BaseModel):
    permitResultList: Optional[List[PermitResult]] = Field(
        None, description='List of new permits.'
    )
    pspReference: Optional[str] = Field(
        None,
        description='A unique reference associated with the request. This value is globally unique; quote it when communicating with us about this request.',
    )


class Permit(BaseModel):
    partnerId: Optional[str] = Field(
        None,
        description='Partner ID (when using the permit-per-partner token sharing model).',
    )
    profileReference: Optional[str] = Field(
        None,
        description='The profile to apply to this permit (when using the shared permits model).',
    )
    restriction: Optional[PermitRestriction] = Field(
        None, description='Permit level restriction overrides.'
    )
    resultKey: Optional[str] = Field(
        None, description='The key to link permit requests to permit results.'
    )
    validTillDate: Optional[datetime] = Field(
        None, description='The expiry date for this permit.'
    )


class RecurringDetail(BaseModel):
    additionalData: Optional[Dict[str, str]] = Field(
        None,
        description='This field contains additional data, which may be returned in a particular response.\n\nThe additionalData object consists of entries, each of which includes the key and value.',
    )
    alias: Optional[str] = Field(
        None,
        description='The alias of the credit card number.\n\nApplies only to recurring contracts storing credit card details',
    )
    aliasType: Optional[str] = Field(
        None,
        description='The alias type of the credit card number.\n\nApplies only to recurring contracts storing credit card details.',
    )
    bank: Optional[BankAccount] = Field(
        None, description='A container for bank account data.'
    )
    billingAddress: Optional[Address] = Field(None, description='The billing address.')
    card: Optional[Card] = Field(None, description='A container for card data.')
    contractTypes: Optional[List[str]] = Field(
        None, description='Types of recurring contracts.'
    )
    creationDate: Optional[datetime] = Field(
        None, description='The date when the recurring details were created.'
    )
    firstPspReference: Optional[str] = Field(
        None,
        description='The `pspReference` of the first recurring payment that created the recurring detail.',
    )
    name: Optional[str] = Field(
        None, description='An optional descriptive name for this recurring detail.'
    )
    networkTxReference: Optional[str] = Field(
        None,
        description='Returned in the response if you are not tokenizing with Adyen and are using the Merchant-initiated transactions (MIT) framework from Mastercard or Visa.\n\nThis contains either the Mastercard Trace ID or the Visa Transaction ID.',
    )
    paymentMethodVariant: Optional[str] = Field(
        None,
        description='The  type or sub-brand of a payment method used, e.g. Visa Debit, Visa Corporate, etc. For more information, refer to [PaymentMethodVariant](https://docs.adyen.com/development-resources/paymentmethodvariant).',
    )
    recurringDetailReference: str = Field(
        ..., description='The reference that uniquely identifies the recurring detail.'
    )
    shopperName: Optional[Name] = Field(None, description='The name of the shopper.')
    socialSecurityNumber: Optional[str] = Field(
        None,
        description="A shopper's social security number (only in countries where it is legal to collect).",
    )
    tokenDetails: Optional[TokenDetails] = None
    variant: str = Field(
        ..., description='The payment method, such as “mc", "visa", "ideal", "paypal".'
    )


class RecurringDetailWrapper(BaseModel):
    RecurringDetail_1: Optional[RecurringDetail] = Field(None, alias='RecurringDetail')


class RecurringDetailsResult(BaseModel):
    creationDate: Optional[datetime] = Field(
        None, description='The date when the recurring details were created.'
    )
    details: Optional[List[RecurringDetailWrapper]] = Field(
        None, description='Payment details stored for recurring payments.'
    )
    lastKnownShopperEmail: Optional[str] = Field(
        None, description='The most recent email for this shopper (if available).'
    )
    shopperReference: Optional[str] = Field(
        None,
        description='The reference you use to uniquely identify the shopper (e.g. user ID or account ID).',
    )


class CreatePermitRequest(BaseModel):
    merchantAccount: str = Field(
        ...,
        description='The merchant account identifier, with which you want to process the transaction.',
    )
    permits: List[Permit] = Field(
        ..., description='The permits to create for this recurring contract.'
    )
    recurringDetailReference: str = Field(
        ..., description='The recurring contract the new permits will use.'
    )
    shopperReference: str = Field(
        ...,
        description="The shopper's reference to uniquely identify this shopper (e.g. user ID or account ID).",
    )
